<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>03.컬렉션 중심 프로그래밍</title>
    <script src="js/_.js"></script>
  </head>

  <body>
    <script>
      // 컬렉션 중심 프로그래밍의 4가지 유형과 함수

      // 1. 수집하기 - map, values, pluck 등
      // 2. 거르기 - filter, reject, compact, without 등
      // 3. 찾아내기 - find, some, every 등
      // 4. 접기 - reduce, min, max, group_by, count_by

      var users = [
        {
          id: 10,
          name: "ID",
          age: 36,
        },
        {
          id: 20,
          name: "BJ",
          age: 32,
        },
        {
          id: 30,
          name: "JM",
          age: 32,
        },
        {
          id: 40,
          name: "PJ",
          age: 27,
        },
        {
          id: 50,
          name: "HA",
          age: 25,
        },
        {
          id: 60,
          name: "JE",
          age: 26,
        },
        {
          id: 70,
          name: "JI",
          age: 31,
        },
        {
          id: 80,
          name: "MP",
          age: 23,
        },
        {
          id: 90,
          name: "FP",
          age: 13,
        },
      ];

      // 1. 수집하기 - map
      //    1. values
      //     배열에서는 _map과 동일하기 때문에 다르지만, key:value일 때 유용
      // function _identity(val) {
      //     return val;
      // }

      // function _values(data) {
      //     return _map(data, _identity);
      // }

      // _map은 curryr을 통해 만들었기 때문에 거꾸로 인자를 따로 넣어 사용 가능
      console.log(_map(_identity)(users[0]));

      // 따라서 최종 values.. _map은 함수를 리턴하기 때문에, 인자로 Object를 받으면서 호출
      // let _values = _map(_identity);

      // 원래 객체
      console.log(users[0]);
      // key만 꺼내 배열 만들기
      console.log(_keys(users[0]));
      // value만 꺼내 배열 만들기
      console.log(_values(users[0]));

      let a = 10;
      console.log(_identity(a));

      //    2. pluck (당기기)
      //     'list'와 '해당 list의 요소의 속성'을 인자로 받는다
      // function _pluck(data, key) {
      //     return _map(data, _get(key))
      // }

      console.log(_pluck(users, "age"));
      console.log(_pluck(users, "name"));

      // 2. 거르기
      //    1. reject
      //       _filter는 보조함수의 값이 true인 요소들만을 모아 배열을 만들어 반환
      //        하지만 reject는 보조함수의 값이 true인 요소들을 '제외하고' 나머지를 배열로 반환
      // function _reject(data, predi) {
      //     return _filter(data, function (val) {
      //         // 보조함수의 반환값을 반대로해서 가져온다
      //         return !predi(val);
      //     });
      // }

      // _negate 사용
      // function _reject(data, predi) {
      //     return _filter(data, _negate(predi));
      // }

      // _negate 부정하다
      // function _negate(func) {
      //     return function (val) {
      //         return !func(val)
      //     }
      // }

      console.log(
        _filter(users, function (user) {
          return user.age > 30;
        })
      );
      console.log(
        _reject(users, function (user) {
          return user.age > 30;
        })
      );

      //  2. compact 함수
      // 리스트 내부 요소중 object가 아닌 요소는 버리는 함수
      // const _compact = _filter(_identity);
      console.log(_compact([1, 2, 0, false, null, {}]));

      // 3. 찾아내기  _find
      // 3-1. _find
      // 배열에서 조건에 맞는 첫 번째 요소를 찾았을 때, 그 요소 하나를 꺼내는 함수
      // 원하는 값을 찾은 뒤, 배열에서 빠져나올 수 있는 특징
      // 일치하는 요소가 없다면 undefined 반환
      // _each 함수를 조금 수정해서 사용
      // const _find = _curryr(function (list, predi) {
      //     const keys = _keys(list);

      //     for (let i = 0, len = keys.length; i < len; i++) {
      //         let val = list[keys[i]];
      //         if (predi(val)) return val;
      //     }
      // });

      console.log(
        _find(users, function (user) {
          return user.id === 20;
        })
      );
      // _get과 함께 사용
      console.log(
        _get(
          _find(users, function (user) {
            return user.id === 30;
          }),
          "name"
        )
      );

      _go(
        users,
        _find(function (user) {
          return user.id === 30;
        }),
        _get("id"),
        console.log
      );

      // 3-2. find index
      // 배열에서 조건에 맞는 첫 번째 요소를 찾았을 때, 그 요소의 인덱스를 꺼내는 함수
      // const _find_index = _curryr(function (list, predi) {
      //     const keys = _keys(list);

      //     for (let i = 0, len = keys.length; i < len; i++) {
      //         if (predi(list[keys[i]])) return i;
      //     }
      //     // 일치하는 요소가 없다면, -1 리턴
      //     return -1;
      // });

      console.log(
        _find_index(users, function (user) {
          return user.id === 30;
        })
      );

      // 3-3. some
      // 배열의 요소 중 하나라도 만족하는 요소가 있다면, true 반환
      // function _some(data, predi) {
      //     // predi가 생략되어 실행된다면, default로 identity를 주도록
      //     // predi = predi ||_identity;
      //     return _find_index(data, predi || _identity) != -1;
      // }

      const arr = [1, 2, 3, 4, 5, 6];
      console.log(
        _some(arr, function (val) {
          return val > 5;
        })
      );

      console.log(_some([null, 0, undefined]));

      // 3-4. every
      // 배열의 요소 모두가 일치해야 true 반환
      // false가 하나도 없어야 가능
      // function _every(data, predi) {
      //     return _find_index(data, _negate(predi || _identity)) === -1;
      // }

      console.log(
        _every(arr, function (val) {
          return val > 0;
        })
      );

      console.log(_every([1, 2, 3, 0]));
    </script>
  </body>
</html>
